import { HttpProxyResponse } from "@runlightyear/lightyear";
import { GoogleCalendar } from "../GoogleCalendar";
import { Gadget } from "../types/Gadget";
import { EventTime } from "../types/EventTime";
import { Attendee } from "../types/Attendee";
import { Attachment } from "../types/Attachment";
import { ID } from "../types/ID";
import { RecurrenceRules } from "../types/RecurrenceRules";
import { ExtendedProperties } from "../types/ExtendedProperties";
import { EventVisibility } from "../types/EventVisibility";
import { EventTransparency } from "../types/EventTransparency";
import { Status } from "../types/Status";
import { Reminders } from "../types/Reminders";
import { Source } from "../types/Source";
import { EventResource } from "../types/EventResource";

export interface CreateEventProps {
  /**
   * Calendar identifier. To retrieve calendar IDs call the calendarList.list method. If you want to access the primary calendar of the currently logged in user, use the "primary" keyword.
   */
  calendarId: "primary" | string;

  /**
   * Version number of conference data supported by the API client. Version 0 assumes no conference data support and ignores conference data in the event's body. Version 1 enables support for copying of ConferenceData as well as for creating new conferences using the createRequest field of conferenceData. The default is 0. Acceptable values are 0 to 1, inclusive.
   */
  conferenceDataVersion?: number;

  /**
   * The maximum number of attendees to include in the response. If there are more than the specified number of attendees, only the participant is returned.
   */
  maxAttendees?: number;

  /**
   * Whether to send notifications about the creation of the new event. Note that some emails might still be sent. The default is false.
   *
   *   Acceptable values are:
   *     "all": Notifications are sent to all guests.
   *   "externalOnly": Notifications are sent to non-Google Calendar guests only.
   *   "none": No notifications are sent.
   *   Warning: Using the value none can have significant adverse effects, including events not syncing to external calendars or events being lost altogether for some users. For calendar migration tasks, consider using the events.import method instead.
   */
  sendUpdates?: "all" | "externalOnly" | "none";

  /**
   * Whether API client performing operation supports event attachments. Optional. The default is false.
   */
  supportsAttachments?: boolean;

  /**
   * Whether anyone can invite themselves to the event (deprecated). Optional. The default is false.
   */
  anyoneCanAddSelf?: boolean;

  attachments?: Array<Attachment>;

  /**
   * The attendees of the event. See the Events with attendees guide for more information on scheduling events with other calendar users. Service accounts need to use domain-wide delegation of authority to populate the attendee list.
   */
  attendees?: Array<Attendee>;

  /**
   * The color of the event. This is an ID referring to an entry in the event section of the colors definition (see the colors endpoint). Optional.	writable
   */
  colorId?: string;

  /**
   * The conference-related information, such as details of a Google Meet conference. To create new conference details use the createRequest field. To persist your changes, remember to set the conferenceDataVersion request parameter to 1 for all event modification requests.
   */
  conferenceData?: object;

  /**
   * Description of the event. Can contain HTML.
   */
  description?: string;

  end: EventTime;

  extendedProperties?: ExtendedProperties;

  gadget?: Gadget;

  /**
   * Whether attendees other than the organizer can invite others to the event. Optional. The default is True.
   */
  guestsCanInviteOthers?: boolean;

  /**
   * Whether attendees other than the organizer can modify the event. Optional. The default is False.
   */
  guestsCanModify?: boolean;

  /**
   * Whether attendees other than the organizer can see who the event's attendees are. Optional. The default is True.
   */
  guestsCanSeeOtherGuests?: boolean;

  /**
   * Opaque identifier of the event. When creating new single or recurring events, you can specify their IDs. Provided IDs must follow these rules:
   * characters allowed in the ID are those used in base32hex encoding, i.e. lowercase letters a-v and digits 0-9, see section 3.1.2 in RFC2938
   * the length of the ID must be between 5 and 1024 characters
   * the ID must be unique per calendar
   * Due to the globally distributed nature of the system, we cannot guarantee that ID collisions will be detected at event creation time. To minimize the risk of collisions we recommend using an established UUID algorithm such as one described in RFC4122.
   * If you do not specify an ID, it will be automatically generated by the server.
   *
   * Note that the icalUID and the id are not identical and only one of them should be supplied at event creation time. One difference in their semantics is that in recurring events, all occurrences of one event have different ids while they all share the same icalUIDs.
   */
  id?: ID;

  /**
   * Geographic location of the event as free-form text.
   */
  location?: string;
  originalStartTime?: EventTime;
  recurrence?: RecurrenceRules;
  /**
   * If the event doesn't use the default reminders, this lists the reminders specific to the event, or, if not set, indicates that no reminders are set for this event. The maximum number of override reminders is 5.
   */
  reminders?: Reminders;

  /**
   * Sequence number as per iCalendar.
   */
  sequence?: number;
  source?: Source;
  start: EventTime;
  /**
   * Status of the event.
   */
  status?: Status;
  /**
   * Title of the event.
   */
  summary?: string;

  /**
   * Whether the event blocks time on the calendar.
   */
  transparency?: EventTransparency;

  /**
   * Visibility of the event.
   */
  visibility?: EventVisibility;
}

export interface CreateEventResponse extends HttpProxyResponse {
  data: EventResource;
}

export const createEvent =
  (self: GoogleCalendar) =>
  async (props: CreateEventProps): Promise<CreateEventResponse> => {
    const {
      calendarId,
      conferenceDataVersion,
      maxAttendees,
      sendUpdates,
      supportsAttachments,
      anyoneCanAddSelf,
      attachments,
      attendees,
      colorId,
      conferenceData,
      description,
      end,
      extendedProperties,
      gadget,
      guestsCanInviteOthers,
      guestsCanModify,
      guestsCanSeeOtherGuests,
      id,
      location,
      originalStartTime,
      recurrence,
      reminders,
      sequence,
      source,
      start,
      status,
      summary,
      transparency,
      visibility,
    } = props;

    return await self.post({
      url: `/calendars/${calendarId}/events`,
      params: {
        conferenceDataVersion,
        maxAttendees,
        sendUpdates,
        supportsAttachments,
      },
      data: {
        anyoneCanAddSelf,
        attachments,
        attendees,
        colorId,
        conferenceData,
        description,
        end,
        extendedProperties,
        gadget,
        guestsCanInviteOthers,
        guestsCanModify,
        guestsCanSeeOtherGuests,
        id,
        location,
        originalStartTime,
        recurrence,
        reminders,
        sequence,
        source,
        start,
        status,
        summary,
        transparency,
        visibility,
      },
    });
  };
